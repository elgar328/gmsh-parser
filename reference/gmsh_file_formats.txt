This is the 'Gmsh Reference Manual' for Gmsh 4.15.0 (October 26, 2025).
Copyright (C) 1997-2025 Christophe Geuzaine, Jean-Fran√ßois Remacle

10 Gmsh file formats
********************

This chapter describes Gmsh's native "MSH" file format, used to store
meshes and associated post-processing datasets.  The MSH format exists
in two flavors: ASCII and binary.  The format has a version number that
is independent of Gmsh's main version number.

(Remember that for small post-processing datasets you can also use
human-readable "parsed" post-processing views, as described in *note
Post-processing scripting commands::.  Such "parsed" views do not
require an underlying mesh, and can therefore be easier to use in some
cases.)

10.1 MSH file format
====================

The MSH file format version 4 (current revision: version 4.1) contains
one mandatory section giving information about the file ('$MeshFormat'),
followed by several optional sections defining the physical group names
('$PhysicalName'), the elementary model entities ('$Entities'), the
partitioned entities ('$PartitionedEntities'), the nodes ('$Nodes'), the
elements ('$Elements'), the periodicity relations ('$Periodic'), the
ghost elements ('$GhostElements'), the parametrizations
('$Parametrizations') and the post-processing datasets ('$NodeData',
'$ElementData', '$ElementNodeData').  The sections reflect the
underlying Gmsh data model: '$Entities' store the boundary
representation of the model geometrical entities, '$Nodes' and
'$Elements' store mesh data classified on these entities, and
'$NodeData', '$ElementData', '$ElementNodeData' store post-processing
data (views).  (See *note Gmsh application programming interface:: and
*note Source code structure:: for a more detailed description of the
internal Gmsh data model.)

To represent a simple mesh, the minimal sections that should be present
in the file are '$MeshFormat', '$Nodes' and '$Elements'.  Nodes are
assumed to be defined before elements.  To represent a mesh with the
full topology (BRep) of the model and associated physical groups, an
'$Entities' section should be present before the '$Nodes' section.
Sections can be repeated in the same file, and post-processing sections
can be put into separate files (e.g.  one file per time step).  Any
section with an unrecognized header is stored by default as a model
attribute: you can thus e.g.  add comments in a '.msh' file by putting
them inside a '$Comments'/'$EndComments' section.  Unrocognized sections
can be ignored altogether if the 'Mesh.IgnoreUnknownSections' option is
set.

All the node, element, entity and physical group tags (their global
identification numbers) should be strictly positive.  (Tag '0' is
reserved for internal use.)  Important note about efficiency: tags can
be "sparse", i.e., do not have to constitute a continuous list of
numbers (the format even allows them to not be ordered).  However, using
sparse node or element tags can lead to performance degradation.  For
meshes, sparse indexing can(1) (*note MSH file format-Footnote-1::)
force Gmsh to use a map instead of a vector to access nodes and
elements.  The performance hit is on speed.  For post-processing
datasets, which always use vectors to access data, the performance hit
is on memory.  A '$NodeData' with two nodes, tagged 1 and 1000000, will
allocate a (mostly empty) vector of 1000000 elements.  By default, for
non-partitioned, single file meshes, Gmsh will create files with a
continuous ordering of node and element tags, starting at 1.  Detecting
if the numbering is continuous can be done easily when reading a file by
inspecting 'numNodes', 'minNodeTag' and 'maxNodeTag' in the '$Nodes'
section; and 'numElements', 'minElementTag' and 'maxElementTag' in the
'$Elements' section.

In binary mode ('Mesh.Binary=1' or '-bin' on the command line), all the
numerical values (integer and floating point) not marked as ASCII in the
format description below are written in binary form, using the type
given between parentheses.  The block structure of the '$Nodes' and
'$Elements' sections allows to read integer and floating point data in
each block in a single step (e.g.  using 'fread' in C).

The format is defined as follows:

     $MeshFormat // same as MSH version 2
       version(ASCII double; currently 4.1)
         file-type(ASCII int; 0 for ASCII mode, 1 for binary mode)
         data-size(ASCII int; sizeof(size_t))
       < int with value one; only in binary mode, to detect endianness >
     $EndMeshFormat

     $PhysicalNames // same as MSH version 2
       numPhysicalNames(ASCII int)
       dimension(ASCII int) physicalTag(ASCII int) "name"(127 characters max)
       ...
     $EndPhysicalNames

     $Entities
       numPoints(size_t) numCurves(size_t)
         numSurfaces(size_t) numVolumes(size_t)
       pointTag(int) X(double) Y(double) Z(double)
         numPhysicalTags(size_t) physicalTag(int) ...
       ...
       curveTag(int) minX(double) minY(double) minZ(double)
         maxX(double) maxY(double) maxZ(double)
         numPhysicalTags(size_t) physicalTag(int) ...
         numBoundingPoints(size_t) pointTag(int; sign encodes orientation) ...
       ...
       surfaceTag(int) minX(double) minY(double) minZ(double)
         maxX(double) maxY(double) maxZ(double)
         numPhysicalTags(size_t) physicalTag(int) ...
         numBoundingCurves(size_t) curveTag(int; sign encodes orientation) ...
       ...
       volumeTag(int) minX(double) minY(double) minZ(double)
         maxX(double) maxY(double) maxZ(double)
         numPhysicalTags(size_t) physicalTag(int) ...
         numBoundngSurfaces(size_t) surfaceTag(int; sign encodes orientation) ...
       ...
     $EndEntities

     $PartitionedEntities
       numPartitions(size_t)
       numGhostEntities(size_t)
         ghostEntityTag(int) partition(int)
         ...
       numPoints(size_t) numCurves(size_t)
         numSurfaces(size_t) numVolumes(size_t)
       pointTag(int) parentDim(int) parentTag(int)
         numPartitions(size_t) partitionTag(int) ...
         X(double) Y(double) Z(double)
         numPhysicalTags(size_t) physicalTag(int) ...
       ...
       curveTag(int) parentDim(int) parentTag(int)
         numPartitions(size_t) partitionTag(int) ...
         minX(double) minY(double) minZ(double)
         maxX(double) maxY(double) maxZ(double)
         numPhysicalTags(size_t) physicalTag(int) ...
         numBoundingPoints(size_t) pointTag(int) ...
       ...
       surfaceTag(int) parentDim(int) parentTag(int)
         numPartitions(size_t) partitionTag(int) ...
         minX(double) minY(double) minZ(double)
         maxX(double) maxY(double) maxZ(double)
         numPhysicalTags(size_t) physicalTag(int) ...
         numBoundingCurves(size_t) curveTag(int) ...
       ...
       volumeTag(int) parentDim(int) parentTag(int)
         numPartitions(size_t) partitionTag(int) ...
         minX(double) minY(double) minZ(double)
         maxX(double) maxY(double) maxZ(double)
         numPhysicalTags(size_t) physicalTag(int) ...
         numBoundingSurfaces(size_t) surfaceTag(int) ...
       ...
     $EndPartitionedEntities

     $Nodes
       numEntityBlocks(size_t) numNodes(size_t)
         minNodeTag(size_t) maxNodeTag(size_t)
       entityDim(int) entityTag(int) parametric(int; 0 or 1)
         numNodesInBlock(size_t)
         nodeTag(size_t)
         ...
         x(double) y(double) z(double)
            < u(double; if parametric and entityDim >= 1) >
            < v(double; if parametric and entityDim >= 2) >
            < w(double; if parametric and entityDim == 3) >
         ...
       ...
     $EndNodes

     $Elements
       numEntityBlocks(size_t) numElements(size_t)
         minElementTag(size_t) maxElementTag(size_t)
       entityDim(int) entityTag(int) elementType(int; see below)
         numElementsInBlock(size_t)
         elementTag(size_t) nodeTag(size_t) ...
         ...
       ...
     $EndElements

     $Periodic
       numPeriodicLinks(size_t)
       entityDim(int) entityTag(int) entityTagMaster(int)
       numAffine(size_t) value(double) ...
       numCorrespondingNodes(size_t)
         nodeTag(size_t) nodeTagMaster(size_t)
         ...
       ...
     $EndPeriodic

     $GhostElements
       numGhostElements(size_t)
       elementTag(size_t) partitionTag(int)
         numGhostPartitions(size_t) ghostPartitionTag(int) ...
       ...
     $EndGhostElements

     $Parametrizations
       numCurveParam(size_t) numSurfaceParam(size_t)
       curveTag(int) numNodes(size_t)
         nodeX(double) nodeY(double) nodeZ(double) nodeU(double)
         ...
       ...
       surfaceTag(int) numNodes(size_t) numTriangles(size_t)
         nodeX(double) nodeY(double) nodeZ(double)
           nodeU(double) nodeV(double)
           curvMaxX(double) curvMaxY(double) curvMaxZ(double)
           curvMinX(double) curvMinY(double) curvMinZ(double)
         ...
         nodeIndex1(int) nodeIndex2(int) nodeIndex3(int)
         ...
       ...
     $EndParametrizations

     $NodeData
       numStringTags(ASCII int)
       stringTag(string) ...
       numRealTags(ASCII int)
       realTag(ASCII double) ...
       numIntegerTags(ASCII int)
       integerTag(ASCII int) ...
       nodeTag(int) value(double) ...
       ...
     $EndNodeData

     $ElementData
       numStringTags(ASCII int)
       stringTag(string) ...
       numRealTags(ASCII int)
       realTag(ASCII double) ...
       numIntegerTags(ASCII int)
       integerTag(ASCII int) ...
       elementTag(int) value(double) ...
       ...
     $EndElementData

     $ElementNodeData
       numStringTags(ASCII int)
       stringTag(string) ...
       numRealTags(ASCII int)
       realTag(ASCII double) ...
       numIntegerTags(ASCII int)
       integerTag(ASCII int) ...
       elementTag(int) numNodesPerElement(int) value(double) ...
       ...
     $EndElementNodeData

     $InterpolationScheme
       name(string)
       numElementTopologies(ASCII int)
       elementTopology
       numInterpolationMatrices(ASCII int)
       numRows(ASCII int) numColumns(ASCII int) value(ASCII double) ...
     $EndInterpolationScheme

In the format description above, 'elementType' is e.g.:
'1'
     2-node line.
'2'
     3-node triangle.
'3'
     4-node quadrangle.
'4'
     4-node tetrahedron.
'5'
     8-node hexahedron.
'6'
     6-node prism.
'7'
     5-node pyramid.
'8'
     3-node second order line (2 nodes associated with the vertices and
     1 with the edge).
'9'
     6-node second order triangle (3 nodes associated with the vertices
     and 3 with the edges).
'10'
     9-node second order quadrangle (4 nodes associated with the
     vertices, 4 with the edges and 1 with the face).
'11'
     10-node second order tetrahedron (4 nodes associated with the
     vertices and 6 with the edges).
'12'
     27-node second order hexahedron (8 nodes associated with the
     vertices, 12 with the edges, 6 with the faces and 1 with the
     volume).
'13'
     18-node second order prism (6 nodes associated with the vertices, 9
     with the edges and 3 with the quadrangular faces).
'14'
     14-node second order pyramid (5 nodes associated with the vertices,
     8 with the edges and 1 with the quadrangular face).
'15'
     1-node point.
'16'
     8-node second order quadrangle (4 nodes associated with the
     vertices and 4 with the edges).
'17'
     20-node second order hexahedron (8 nodes associated with the
     vertices and 12 with the edges).
'18'
     15-node second order prism (6 nodes associated with the vertices
     and 9 with the edges).
'19'
     13-node second order pyramid (5 nodes associated with the vertices
     and 8 with the edges).
'20'
     9-node third order incomplete triangle (3 nodes associated with the
     vertices, 6 with the edges)
'21'
     10-node third order triangle (3 nodes associated with the vertices,
     6 with the edges, 1 with the face)
'22'
     12-node fourth order incomplete triangle (3 nodes associated with
     the vertices, 9 with the edges)
'23'
     15-node fourth order triangle (3 nodes associated with the
     vertices, 9 with the edges, 3 with the face)
'24'
     15-node fifth order incomplete triangle (3 nodes associated with
     the vertices, 12 with the edges)
'25'
     21-node fifth order complete triangle (3 nodes associated with the
     vertices, 12 with the edges, 6 with the face)
'26'
     4-node third order edge (2 nodes associated with the vertices, 2
     internal to the edge)
'27'
     5-node fourth order edge (2 nodes associated with the vertices, 3
     internal to the edge)
'28'
     6-node fifth order edge (2 nodes associated with the vertices, 4
     internal to the edge)
'29'
     20-node third order tetrahedron (4 nodes associated with the
     vertices, 12 with the edges, 4 with the faces)
'30'
     35-node fourth order tetrahedron (4 nodes associated with the
     vertices, 18 with the edges, 12 with the faces, 1 in the volume)
'31'
     56-node fifth order tetrahedron (4 nodes associated with the
     vertices, 24 with the edges, 24 with the faces, 4 in the volume)
'92'
     64-node third order hexahedron (8 nodes associated with the
     vertices, 24 with the edges, 24 with the faces, 8 in the volume)
'93'
     125-node fourth order hexahedron (8 nodes associated with the
     vertices, 36 with the edges, 54 with the faces, 27 in the volume)
'...'
All the currently supported elements in the format are defined in
GmshDefines.h
(https://gitlab.onelab.info/gmsh/gmsh/blob/master/src/common/GmshDefines.h).
See *note Node ordering:: for the ordering of the nodes.

The post-processing sections ('$NodeData', '$ElementData',
'$ElementNodeData') can contain 'numStringTags' string tags,
'numRealTags' real value tags and 'numIntegerTags' integer tags.  The
default set of tags understood by Gmsh is as follows:
'stringTag'
     The first is interpreted as the name of the post-processing view
     and the second as the name of the interpolation scheme, as provided
     in the '$InterpolationScheme' section.
'realTag'
     The first is interpreted as a time value associated with the
     dataset.
'integerTag'
     The first is interpreted as a time step index (starting at 0), the
     second as the number of field components of the data in the view
     (1, 3 or 9), the third as the number of entities (nodes or
     elements) in the view, and the fourth as the partition index for
     the view data (0 for no partition).

In the '$InterpolationScheme' section:
'numElementTopologies'
     is the number of element topologies for which interpolation
     matrices are provided.
'elementTopology'
     is the id tag of a given element topology: 1 for points, 2 for
     lines, 3 for triangles, 4 for quadrangles, 5 for tetrahedra, 6 for
     pyramids, 7 for prisms, 8 for hexahedra, 9 for polygons and 10 for
     polyhedra.
'numInterpolationMatrices'
     is the number of interpolation matrices provided for the given
     element topology.  Currently you should provide 2 matrices, i.e.,
     the matrices that specify how to interpolate the data (they have
     the same meaning as in *note Post-processing scripting commands::).
     The matrices are specified by 2 integers ('numRows' and
     'numColumns') followed by the values, by row.

Here is a small example of a minimal ASCII MSH4.1 file, with a mesh
consisting of two quadrangles and an associated nodal scalar dataset
(the comments are not part of the actual file):

     $MeshFormat
     4.1 0 8     _MSH4.1, ASCII_
     $EndMeshFormat
     $Nodes
     1 6 1 6     _1 entity bloc, 6 nodes total, min/max node tags: 1 and 6_
     2 1 0 6     _2D entity (surface) 1, no parametric coordinates, 6 nodes_
     1           _  node tag #1_
     2           _  node tag #2_
     3           _  etc._
     4
     5
     6
     0. 0. 0.    _  node #1 coordinates (0., 0., 0.)_
     1. 0. 0.    _  node #2 coordinates (1., 0., 0.)_
     1. 1. 0.    _  etc._
     0. 1. 0.
     2. 0. 0.
     2. 1. 0.
     $EndNodes
     $Elements
     1 2 1 2     _1 entity bloc, 2 elements total, min/max element tags: 1 and 2_
     2 1 3 2     _2D entity (surface) 1, element type 3 (4-node quad), 2 elements_
     1 1 2 3 4   _  quad tag #1, nodes 1 2 3 4_
     2 2 5 6 3   _  quad tag #2, nodes 2 5 6 3_
     $EndElements
     $NodeData
     1           _1 string tag:_
     "My view"   _  the name of the view ("My view")_
     1           _1 real tag:_
     0.0         _  the time value (0.0)_
     3           _3 integer tags:_
     0           _  the time step (0; time steps always start at 0)_
     1           _  1-component (scalar) field_
     6           _  6 associated nodal values_
     1 0.0       _value associated with node #1 (0.0)_
     2 0.1       _value associated with node #2 (0.1)_
     3 0.2       _etc._
     4 0.0
     5 0.2
     6 0.4
     $EndNodeData

The 4.1 revision of the format includes the following modifications with
respect to the initial 4.0 version:
   * All the 'unsigned long' entries have been changed to 'size_t'.  All
     the entries designating counts which were previously encoded as
     'int' have also been changed to 'size_t'.  (This only impacts
     binary files.)
   * The '$Entities' section is now optional.
   * Integer and floating point data in the '$Nodes' section is not
     mixed anymore: all the tags are given first, followed by all the
     coordinates.
   * The bounding box for point entities has been replaced simply by the
     3 coordinates of the point (instead of the six bounding box
     values).
   * The 'entityDim' and 'entityTag' values have been switched in the
     '$Nodes' and '$Elements' sections (for consistency with the
     ordering used elsewhere in the file and in the *note Gmsh
     application programming interface::).
   * The minimum and the maximum tag of nodes (resp.  elements) have
     been added in the header of the '$Nodes' (resp.  '$Elements')
     section, to facilitate the detection of sparse or dense numberings
     when reading the file.
   * The '$Periodic' section has been changed to always provide the
     number of values in the affine transform (which can be zero, if the
     transform is not provided).

The following changes are foreseen in a future revision of the MSH
format:
   * The '$GhostElements', '$NodeData', '$ElementData' and
     '$ElementNodeData' will be reworked for greater IO efficiency, with
     separation of entries by type and a block structure with
     predictable sizes.
   * Node and element tags in '$NodeData', '$ElementData' and
     '$ElementNodeData' will be switched to 'size_t'.

   (1) If the numbering is not too sparse, Gmsh will still use a vector.

10.2 Node ordering
==================

Historically, Gmsh first supported linear elements (lines, triangles,
quadrangles, tetrahedra, prisms and hexahedra).  Then, support for
second and some third order elements has been added.  Below we
distinguish such "low order elements", which are hardcoded (i.e.  they
are explicitly defined in the code), and general "high-order elements",
that have been coded in a more general fashion, theoretically valid for
any order.

10.2.1 Low order elements
-------------------------

For all mesh and post-processing file formats, the reference elements
are defined as follows.

     Line:                  Line3:           Line4:

           v
           ^
           |
           |
     0-----+-----1 --> u    0----2----1      0---2---3---1


     Triangle:               Triangle6:          Triangle9/10:

     v
     ^
     |
     2                       2                    2
     |`\                     |`\                  | \
     |  `\                   |  `\                7   6
     |    `\                 5    `4              |     \
     |      `\               |      `\            8  (9)  5
     |        `\             |        `\          |         \
     0----------1--> u       0-----3----1         0---3---4---1


     Triangle12/15:

      v
      ^
      |
      2
      | \
      9   8
      |     \
     10 (14)  7
      |         \
     11 (12) (13) 6
      |             \
      0---3---4---5---1--> u


     Quadrangle:            Quadrangle8:            Quadrangle9:

           v
           ^
           |
     3-----------2          3-----6-----2           3-----6-----2
     |     |     |          |           |           |           |
     |     |     |          |           |           |           |
     |     +---- | --> u    7           5           7     8     5
     |           |          |           |           |           |
     |           |          |           |           |           |
     0-----------1          0-----4-----1           0-----4-----1


     Tetrahedron:                          Tetrahedron10:

                        v
                      .
                    ,/
                   /
                2                                     2
              ,/|`\                                 ,/|`\
            ,/  |  `\                             ,/  |  `\
          ,/    '.   `\                         ,6    '.   `5
        ,/       |     `\                     ,/       8     `\
      ,/         |       `\                 ,/         |       `\
     0-----------'.--------1 --> u         0--------4--'.--------1
      `\.         |      ,/                 `\.         |      ,/
         `\.      |    ,/                      `\.      |    ,9
            `\.   '. ,/                           `7.   '. ,/
               `\. |/                                `\. |/
                  `3                                    `3
                     `\.
                        ` w

     Hexahedron:             Hexahedron20:          Hexahedron27:

            v
     3----------2            3----13----2           3----13----2
     |\     ^   |\           |\         |\          |\         |\
     | \    |   | \          | 15       | 14        |15    24  | 14
     |  \   |   |  \         9  \       11 \        9  \ 20    11 \
     |   7------+---6        |   7----19+---6       |   7----19+---6
     |   |  +-- |-- | -> u   |   |      |   |       |22 |  26  | 23|
     0---+---\--1   |        0---+-8----1   |       0---+-8----1   |
      \  |    \  \  |         \  17      \  18       \ 17    25 \  18
       \ |     \  \ |         10 |        12|        10 |  21    12|
        \|      w  \|           \|         \|          \|         \|
         4----------5            4----16----5           4----16----5


     Prism:                      Prism15:               Prism18:

                w
                ^
                |
                3                       3                      3
              ,/|`\                   ,/|`\                  ,/|`\
            ,/  |  `\               12  |  13              12  |  13
          ,/    |    `\           ,/    |    `\          ,/    |    `\
         4------+------5         4------14-----5        4------14-----5
         |      |      |         |      8      |        |      8      |
         |    ,/|`\    |         |      |      |        |    ,/|`\    |
         |  ,/  |  `\  |         |      |      |        |  15  |  16  |
         |,/    |    `\|         |      |      |        |,/    |    `\|
        ,|      |      |\        10     |      11       10-----17-----11
      ,/ |      0      | `\      |      0      |        |      0      |
     u   |    ,/ `\    |    v    |    ,/ `\    |        |    ,/ `\    |
         |  ,/     `\  |         |  ,6     `7  |        |  ,6     `7  |
         |,/         `\|         |,/         `\|        |,/         `\|
         1-------------2         1------9------2        1------9------2


     Pyramid:                     Pyramid13:

                    4                            4
                  ,/|\                         ,/|\
                ,/ .'|\                      ,/ .'|\
              ,/   | | \                   ,/   | | \
            ,/    .' | `.                ,/    .' | `.
          ,/      |  '.  \             ,7      |  12  \
        ,/       .' w |   \          ,/       .'   |   \
      ,/         |  ^ |    \       ,/         9    |    11
     0----------.'--|-3    `.     0--------6-.'----3    `.
      `\        |   |  `\    \      `\        |      `\    \
        `\     .'   +----`\ - \ -> v  `5     .'        10   \
          `\   |    `\     `\  \        `\   |           `\  \
            `\.'      `\     `\`          `\.'             `\`
               1----------------2            1--------8-------2
                         `\
                            u

     Pyramid14:

                    4
                  ,/|\
                ,/ .'|\
              ,/   | | \
            ,/    .' | `.
          ,7      |  12  \
        ,/       .'   |   \
      ,/         9    |    11
     0--------6-.'----3    `.
       `\        |      `\    \
         `5     .' 13     10   \
           `\   |           `\  \
             `\.'             `\`
                1--------8-------2
                         `\
                            u

10.2.2 High-order elements
--------------------------

The node ordering of a higher order (possibly curved) element is
compatible with the numbering of low order element (it is a
generalization).  We number nodes in the following order:
   - the element principal or corner vertices;
   - the internal nodes for each edge;
   - the internal nodes for each face;
   - the volume internal nodes.

The numbering for internal nodes is recursive, i.e.  the numbering
follows that of the nodes of an embedded edge/face/volume of lower
order.  The higher order nodes are assumed to be equispaced.  Edges and
faces are numbered following the lowest order template that generates a
single high-order on this edge/face.  Furthermore, an edge is oriented
from the node with the lowest to the highest index.  The orientation of
a face is such that the computed normal points outward; the starting
point is the node with the lowest index.

